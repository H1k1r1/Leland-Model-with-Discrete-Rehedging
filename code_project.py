# -*- coding: utf-8 -*-
"""code_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14SvkOIAYiGTqptuSGazTqNHQ69d-yxjM
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import ttest_ind, mannwhitneyu, ks_2samp, pearsonr, norm
import random

np.random.seed(42)
random.seed(42)

# ============================================================
# ЧАСТЬ 1: Black-Scholes и Leland Model с дискретным хеджем
# ============================================================

def bs_call_price(S, K, r, T, sigma):
    if sigma <= 0 or T <= 0:
        return max(S - K, 0.0)
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

def bs_delta_call(S, K, r, T, sigma):
    if sigma <= 0 or T <= 0:
        return 1.0 if S > K else 0.0
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    return norm.cdf(d1)

def bs_gamma_call(S, K, r, T, sigma):
    if sigma <= 0 or T <= 0:
        return 0.0
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    return norm.pdf(d1) / (S * sigma * np.sqrt(T))

def leland_price_adjustment(gamma, sigma, rehedge_interval, transaction_cost):
    if rehedge_interval <= 0 or transaction_cost <= 0:
        return 0.0
    adjustment = gamma * sigma * np.sqrt(rehedge_interval) * transaction_cost / np.sqrt(np.pi)
    return adjustment

# ============================================================
# ЧАСТЬ 2: Мультиагентная симуляция с дискретным хеджем
# ============================================================

def run_leland_simulation(
    T=1000,
    N=150,
    # Параметры хеджирования
    frac_frequent_hedgers=0.15,   # агенты, хеджирующие часто (каждый день)
    frac_infrequent_hedgers=0.1,  # агенты, хеджирующие редко (раз в 5-10 дней)
    # Другие агенты
    frac_momentum=0.2,
    frac_fundamentalists=0.15,
    # Параметры рынка
    base_lambda=0.001,
    transaction_cost=0.001,  # издержки на одну сделку
    S0=100.0,
    K=100.0,
    r=0.01,
    sigma_underlying=0.2,  # волатильность спота
    T_mat_years=30/252
):

    S = S0
    prices = [S]
    returns = []
    logreturns = []

    # Портфели хеджеров
    frequent_inventory = 1.0  # один long call на агента
    infrequent_inventory = 1.0
    frequent_stock_pos = 0.0  # stock position для хеджа
    infrequent_stock_pos = 0.0

    # Счётчики для дискретного хеджа
    rehedge_freq_counter = 0
    rehedge_infreq_counter = 0

    # Агенты
    n_frequent = int(frac_frequent_hedgers * N)
    n_infrequent = int(frac_infrequent_hedgers * N)
    n_momentum = int(frac_momentum * N)
    n_fundamentalists = int(frac_fundamentalists * N)
    n_noise = N - n_frequent - n_infrequent - n_momentum - n_fundamentalists

    # Метрики для анализа
    transaction_costs_list = []
    gamma_pnl_list = []
    realized_costs_vs_predicted = []

    for t in range(1, T+1):

        # -------- СПРОС ДРУГИХ АГЕНТОВ --------
        last_r = logreturns[-1] if len(logreturns) > 0 else 0.0
        dmom = n_momentum * 0.5 * np.sign(last_r) * abs(last_r)

        dfund = n_fundamentalists * 0.1 * np.log(100.0 / S)

        dnoise = np.random.normal(scale=0.5, size=n_noise).sum()

        # -------- ДИСКРЕТНОЕ ХЕДЖИРОВАНИЕ --------
        delta_current = bs_delta_call(S, K, r, T_mat_years - t/252, sigma_underlying)
        gamma_current = bs_gamma_call(S, K, r, T_mat_years - t/252, sigma_underlying)

        # Частое хеджирование (каждый день, t % 1 == 0)
        frequent_hedge_trade = 0.0
        if rehedge_freq_counter >= 1:  # каждый день
            target_stock_frequent = -frequent_inventory * n_frequent * delta_current
            frequent_hedge_trade = target_stock_frequent - frequent_stock_pos
            frequent_stock_pos = target_stock_frequent
            rehedge_freq_counter = 0
            # Учитываем транзакционные издержки
            freq_cost = abs(frequent_hedge_trade) * transaction_cost
            transaction_costs_list.append(freq_cost)
        else:
            rehedge_freq_counter += 1

        # Редкое хеджирование (раз в 5 дней)
        infreq_hedge_trade = 0.0
        if rehedge_infreq_counter >= 5:
            target_stock_infreq = -infrequent_inventory * n_infrequent * delta_current
            infreq_hedge_trade = target_stock_infreq - infrequent_stock_pos
            infrequent_stock_pos = target_stock_infreq
            rehedge_infreq_counter = 0
            # Издержки выше из-за более крупных сделок
            infreq_cost = abs(infreq_hedge_trade) * transaction_cost * 1.5
            transaction_costs_list.append(infreq_cost)
        else:
            rehedge_infreq_counter += 1

        # P&L от гамма (hedging P&L)
        if len(logreturns) > 0:
            dS_log = logreturns[-1]
            gamma_pnl = 0.5 * gamma_current * (S ** 2) * (dS_log ** 2)
            gamma_pnl_list.append(gamma_pnl)

        # -------- ЦЕНА --------
        net_order = dmom + dfund + dnoise + frequent_hedge_trade + infreq_hedge_trade

        effective_lambda = base_lambda
        dlogS = effective_lambda * net_order + np.random.normal(scale=0.001)

        if np.random.rand() < 0.002:
            dlogS += np.random.standard_t(df=4) * 0.05

        S = S * np.exp(dlogS)
        prices.append(S)

        if len(prices) > 1:
            lr = np.log(prices[-1] / prices[-2])
            logreturns.append(lr)
            returns.append(lr)

    # ======================================================
    #                     МЕТРИКИ
    # ======================================================
    df = pd.DataFrame({
        "time": range(len(prices)),
        "price": prices,
        "logreturn": [0.0] + returns,
    })

    realized_vol = np.std(logreturns) * np.sqrt(252) if len(logreturns) > 1 else 0.0
    total_transaction_costs = sum(transaction_costs_list)
    avg_transaction_costs = np.mean(transaction_costs_list) if transaction_costs_list else 0.0
    extreme_count = np.sum(np.abs(df["logreturn"]) > 3 * df["logreturn"].std())
    kurt = df["logreturn"].kurtosis()
    avg_gamma_pnl = np.mean(gamma_pnl_list) if gamma_pnl_list else 0.0

    metrics = {
        "realized_vol": realized_vol,
        "total_transaction_costs": total_transaction_costs,
        "avg_transaction_costs": avg_transaction_costs,
        "extreme_count": extreme_count,
        "kurtosis": kurt,
        "avg_gamma_pnl": avg_gamma_pnl,
    }

    return df, metrics

# ============================================================
# ЧАСТЬ 3: Трёхэтапное тестирование гипотез
# ============================================================

print("=" * 70)
print("LELAND MODEL WITH DISCRETE REHEDGING - HYPOTHESIS TESTING")
print("=" * 70)

# H1: Частое хеджирование vs редкое хеджирование
print("\n--- SCENARIO 1: Frequent vs Infrequent Hedging ---")
metrics_frequent, dfs_frequent = [], []
metrics_infrequent, dfs_infrequent = [], []

for i in range(35):
    df, m = run_leland_simulation(
        frac_frequent_hedgers=0.20,
        frac_infrequent_hedgers=0.02
    )
    metrics_frequent.append(m)
    dfs_frequent.append(df)

for i in range(35):
    df, m = run_leland_simulation(
        frac_frequent_hedgers=0.02,
        frac_infrequent_hedgers=0.20
    )
    metrics_infrequent.append(m)
    dfs_infrequent.append(df)

metrics_frequent_df = pd.DataFrame(metrics_frequent)
metrics_infrequent_df = pd.DataFrame(metrics_infrequent)

# H2: Высокие vs низкие транзакционные издержки
print("\n--- SCENARIO 2: High vs Low Transaction Costs ---")
metrics_high_cost, dfs_high_cost = [], []
metrics_low_cost, dfs_low_cost = [], []

for i in range(35):
    df, m = run_leland_simulation(
        transaction_cost=0.005  # 0.5%
    )
    metrics_high_cost.append(m)
    dfs_high_cost.append(df)

for i in range(35):
    df, m = run_leland_simulation(
        transaction_cost=0.0001  # 0.01%
    )
    metrics_low_cost.append(m)
    dfs_low_cost.append(df)

metrics_high_cost_df = pd.DataFrame(metrics_high_cost)
metrics_low_cost_df = pd.DataFrame(metrics_low_cost)

# H3: Связь между частотой хеджирования, издержками и системным риском
print("\n--- SCENARIO 3: Hedging Frequency vs Systemic Risk ---")
metrics_mixed, dfs_mixed = [], []

for i in range(35):
    df, m = run_leland_simulation(
        frac_frequent_hedgers=0.10,
        frac_infrequent_hedgers=0.10,
        transaction_cost=0.002
    )
    metrics_mixed.append(m)
    dfs_mixed.append(df)

metrics_mixed_df = pd.DataFrame(metrics_mixed)

# ============================================================
# ЧАСТЬ 4: Статистические тесты
# ============================================================

print("\n" + "=" * 70)
print("STATISTICAL TESTS")
print("=" * 70)

tests = {}

# H1: Частое хеджирование снижает транзакционные издержки
stat_t_H1, p_t_H1 = ttest_ind(
    metrics_frequent_df["total_transaction_costs"],
    metrics_infrequent_df["total_transaction_costs"],
    equal_var=False
)
stat_mw_H1, p_mw_H1 = mannwhitneyu(
    metrics_frequent_df["total_transaction_costs"],
    metrics_infrequent_df["total_transaction_costs"],
    alternative="two-sided"
)

tests["H1_ttest_costs"] = (stat_t_H1, p_t_H1)
tests["H1_mannwhitney_costs"] = (stat_mw_H1, p_mw_H1)

# H2: Высокие издержки увеличивают реализованную волатильность
stat_t_H2, p_t_H2 = ttest_ind(
    metrics_high_cost_df["realized_vol"],
    metrics_low_cost_df["realized_vol"],
    equal_var=False
)
stat_ks_H2, p_ks_H2 = ks_2samp(
    metrics_high_cost_df["extreme_count"],
    metrics_low_cost_df["extreme_count"]
)

tests["H2_ttest_vol"] = (stat_t_H2, p_t_H2)
tests["H2_ks_extreme"] = (stat_ks_H2, p_ks_H2)

# H3: Корреляция между издержками и куртозисом (системный риск)
corr_H3, p_corr_H3 = pearsonr(
    metrics_mixed_df["total_transaction_costs"],
    metrics_mixed_df["kurtosis"]
)
stat_t_H3, p_t_H3 = ttest_ind(
    metrics_frequent_df["extreme_count"],
    metrics_infrequent_df["extreme_count"],
    equal_var=False
)

tests["H3_corr_costs_kurtosis"] = (corr_H3, p_corr_H3)
tests["H3_ttest_extremes"] = (stat_t_H3, p_t_H3)

# ============================================================
# ЧАСТЬ 5: Вывод результатов
# ============================================================

summary = pd.DataFrame({
    "scenario": ["frequent_hedging", "infrequent_hedging", "high_cost", "low_cost"],
    "mean_transaction_costs": [
        metrics_frequent_df["total_transaction_costs"].mean(),
        metrics_infrequent_df["total_transaction_costs"].mean(),
        metrics_high_cost_df["total_transaction_costs"].mean(),
        metrics_low_cost_df["total_transaction_costs"].mean(),
    ],
    "mean_realized_vol": [
        metrics_frequent_df["realized_vol"].mean(),
        metrics_infrequent_df["realized_vol"].mean(),
        metrics_high_cost_df["realized_vol"].mean(),
        metrics_low_cost_df["realized_vol"].mean(),
    ],
    "mean_extreme_count": [
        metrics_frequent_df["extreme_count"].mean(),
        metrics_infrequent_df["extreme_count"].mean(),
        metrics_high_cost_df["extreme_count"].mean(),
        metrics_low_cost_df["extreme_count"].mean(),
    ],
    "mean_kurtosis": [
        metrics_frequent_df["kurtosis"].mean(),
        metrics_infrequent_df["kurtosis"].mean(),
        metrics_high_cost_df["kurtosis"].mean(),
        metrics_low_cost_df["kurtosis"].mean(),
    ],
})

print("\n=== Summary by Scenario ===")
print(summary.to_string(index=False))

print("\n=== Statistical Tests ===")
tests_df = pd.DataFrame(
    [{"test": k, "stat": v[0], "pvalue": v[1]} for k, v in tests.items()]
)
print(tests_df.to_string(index=False))

# ============================================================
# ЧАСТЬ 6: Графики для отчёта
# ============================================================

print("\n=== Generating Plots ===")

example_df = dfs_frequent[0]

fig, axes = plt.subplots(3, 2, figsize=(14, 12))

# 1. Траектория цены (frequent hedging)
axes[0, 0].plot(example_df["time"], example_df["price"], linewidth=1.5)
axes[0, 0].set_title("Price Path (Frequent Hedging)")
axes[0, 0].set_ylabel("Price")
axes[0, 0].grid(True, alpha=0.3)

# 2. Траектория цены (infrequent hedging)
example_df_infreq = dfs_infrequent[0]
axes[0, 1].plot(example_df_infreq["time"], example_df_infreq["price"], linewidth=1.5, color='orange')
axes[0, 1].set_title("Price Path (Infrequent Hedging)")
axes[0, 1].set_ylabel("Price")
axes[0, 1].grid(True, alpha=0.3)

# 3. Распределение транзакционных издержек
data_freq_costs = metrics_frequent_df["total_transaction_costs"]
data_infreq_costs = metrics_infrequent_df["total_transaction_costs"]
all_costs = np.concatenate([data_freq_costs, data_infreq_costs])
bins_costs = np.linspace(all_costs.min(), all_costs.max(), 20)

axes[1, 0].hist(data_freq_costs, bins=bins_costs, alpha=0.6, label="Frequent", color="tab:blue", edgecolor='black')
axes[1, 0].hist(data_infreq_costs, bins=bins_costs, alpha=0.6, label="Infrequent", color="tab:orange", edgecolor='black')
axes[1, 0].set_title("Transaction Costs Distribution (H1)")
axes[1, 0].set_xlabel("Total Transaction Costs")
axes[1, 0].set_ylabel("Frequency")
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)

# 4. Распределение реализованной волатильности по издержкам
data_high_vol = metrics_high_cost_df["realized_vol"]
data_low_vol = metrics_low_cost_df["realized_vol"]
all_vol = np.concatenate([data_high_vol, data_low_vol])
bins_vol = np.linspace(all_vol.min(), all_vol.max(), 20)

axes[1, 1].hist(data_high_vol, bins=bins_vol, alpha=0.6, label="High Cost", color="tab:red", edgecolor='black')
axes[1, 1].hist(data_low_vol, bins=bins_vol, alpha=0.6, label="Low Cost", color="tab:green", edgecolor='black')
axes[1, 1].set_title("Realized Volatility vs Transaction Costs (H2)")
axes[1, 1].set_xlabel("Annualized Realized Vol")
axes[1, 1].set_ylabel("Frequency")
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3)

# 5. Куртозис vs Издержки (корреляция)
axes[2, 0].scatter(metrics_mixed_df["total_transaction_costs"], metrics_mixed_df["kurtosis"], alpha=0.6, s=50)
axes[2, 0].set_title(f"Costs vs Kurtosis (r={corr_H3:.3f}, p={p_corr_H3:.2e})")
axes[2, 0].set_xlabel("Total Transaction Costs")
axes[2, 0].set_ylabel("Kurtosis (Systemic Risk)")
axes[2, 0].grid(True, alpha=0.3)

# 6. Число экстремумов: frequent vs infrequent
data_ext_freq = metrics_frequent_df["extreme_count"]
data_ext_infreq = metrics_infrequent_df["extreme_count"]
axes[2, 1].boxplot([data_ext_freq, data_ext_infreq], labels=["Frequent", "Infrequent"])
axes[2, 1].set_title("Extreme Events Distribution")
axes[2, 1].set_ylabel("Count of Extremes (|r| > 3σ)")
axes[2, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("\n✓ All analyses completed successfully!")